import { InterpolationMethod } from './interpolation-method.js';
import { DataType } from './datatype.js';
import { Values } from './values.js';
import { TimeEntry } from './time-entry.js';
import { TimeSegment } from './time-segment.js';
import { StatusType } from './status-type.js';
interface Samplable {
    mutableResample(targetTimestamps: Date[]): TimeSeriesPath;
}
export declare class TimeSeriesPath implements Samplable {
    dataType: DataType;
    interpolationMethod: InterpolationMethod;
    timestamps: Date[];
    values: unknown[];
    statuses: StatusType[];
    startTimestamp?: Date;
    endTimestamp?: Date;
    quantityKind?: string;
    measurementUnit?: string;
    measurementUnitMultiplier?: number;
    measurementUnitOffset?: number;
    name?: string;
    description?: string;
    expression?: string;
    error?: Error;
    hint?: string;
    constructor(dataType: DataType, interpolationMethod: InterpolationMethod, startTimestamp?: Date, endTimestamp?: Date, quantityKind?: string, measurementUnit?: string, measurementUnitMultiplier?: number, measurementUnitOffset?: number, name?: string, description?: string, expression?: string);
    validate(): boolean;
    clone(): TimeSeriesPath;
    deepClone(): TimeSeriesPath;
    setTimeVector(timestamps: Date[], values: Values, statuses?: StatusType[]): TimeSeriesPath;
    setTimeEntries(timeEntries: TimeEntry[]): TimeSeriesPath;
    getTimeEntries(): TimeEntry[];
    setTimeSegments(timeSegments: TimeSegment[]): TimeSeriesPath;
    getTimeSegments(): TimeSegment[];
    private _resampleNone;
    private _resamplePrevious;
    private _resampleNext;
    private _setResampleValue;
    protected _resampleLinear(targetTimestamps: Date[]): TimeSeriesPath;
    mutableResample(targetTimestamps: Date[]): TimeSeriesPath;
    resample(targetTimestamps: Date[]): TimeSeriesPath;
    private operator;
    private operatorScalar;
    private operatorTS;
    add(arg: unknown): TimeSeriesPath;
    subtract(arg: unknown): TimeSeriesPath;
    multiply(arg: unknown): TimeSeriesPath;
    divide(arg: unknown): TimeSeriesPath;
    pow(arg: unknown): TimeSeriesPath;
    remainder(arg: unknown): TimeSeriesPath;
    lt(arg: unknown): TimeSeriesPath;
    negate(): TimeSeriesPath;
    private static aggregate;
    static sum(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static avg(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static min(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static max(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static range(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
}
export {};
