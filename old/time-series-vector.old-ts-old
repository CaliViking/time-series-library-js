import { ValueArrayType } from './vector.js';

/**
 * Three arrays for timestamps, values, and statuses
 */
export class TimeSeriesVector<ValueType extends ValueArrayType> {
  vector: Vector<ValueType>;
  valueType: ValueType;

  public set(timestamps: TimestampsClass, values: ValueType, statuses?: StatusesClass) {
    this.vector.timestamps = timestamps;
    this.vector.values = values;
    this.vector.statuses = statuses ?? (new Uint32Array(timestamps.length) as StatusesClass);

    return this;
  }
  /**
   * Slice the time series vector by cutting off beginning and end
   * @param sliceSize The maximum number of time series entries in each object
   */
  public sliceTime(
    fromTimestamp: number,
    toTimestamp: number = this.vector.timestamps[this.vector.timestamps.length],
    mode: SliceMode = SliceMode.IncludeOverflow
  ): TimeSeriesVector<ValueType> {
    /** An array that will contain all the time series path objects to be returned */
    const returnTimeSeriesVector = new TimeSeriesVector<ValueType>();

    const foundStartIndex = forwardFindIndex(
      this.vector.timestamps,
      fromTimestamp,
      mode === SliceMode.ExcludeOverflow ? IndexMode.ExcludeOverflow : IndexMode.IncludeOverflow
    );

    const foundEndIndex = reverseFindIndex(
      this.vector.timestamps,
      toTimestamp,
      mode === SliceMode.ExcludeOverflow ? IndexMode.ExcludeOverflow : IndexMode.IncludeOverflow
    );

    returnTimeSeriesVector.vector = this.vector.slice(foundStartIndex, foundEndIndex + 1);

    return returnTimeSeriesVector;
  }

  /**
   * Append adds a first time series path to a second time series path.
   * If there is overlap between the two paths, then the appendedTimeSeriesPath will take precedence
   * @param appendedTimeSeriesPath The time series path that will be added
   * @returns A new time series path
   */
  public append(appendedTimeSeriesPath: TimeSeriesVector<ValueType>): TimeSeriesVector<ValueType> {
    const vector = this.vector.append(appendedTimeSeriesPath.vector);
    const returnTimeSeriesVector = { ...this };
    returnTimeSeriesVector.vector = vector;
    return returnTimeSeriesVector;
  }

  /**
   * Replaces (by inserting) a new time series vector into section of the original time series vector.
   * Overlapping time ranges in the original time series vector will be removed and replaced with the new points
   * @param timeSeriesVector The time series vector that shall be inserted into the original time series path
   * @returns A new time series vector
   */
  public replace(timeSeriesVector: TimeSeriesVector<ValueType>): TimeSeriesVector<ValueType> {
    const returnTimeSeriesPeriod = { ...this };
    returnTimeSeriesPeriod.vector = this.vector.replace(timeSeriesVector.vector);
    return returnTimeSeriesPeriod;
  }
}
