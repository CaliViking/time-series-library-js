import { InterpolationMethod } from './interpolation-method.js';
import { DataType } from './datatype.js';
import { Values } from './values.js';
import { TimeEntry } from './time-entry.js';
import { TimeSegment } from './time-segment.js';
interface Samplable {
    mutableResample(targetTimestamps: DOMHighResTimeStamp[]): TimeSeriesPath;
}
export declare class TimeSeriesPath implements Samplable {
    dataType: DataType;
    interpolationMethod: InterpolationMethod;
    timestamps: DOMHighResTimeStamp[];
    values: unknown[];
    statuses: number[];
    startTimestamp?: DOMHighResTimeStamp;
    endTimestamp?: DOMHighResTimeStamp;
    quantityKind?: string;
    measurementUnit?: string;
    measurementUnitMultiplier?: number;
    measurementUnitOffset?: number;
    name?: string;
    description?: string;
    expression?: string;
    error?: Error;
    hint?: string;
    constructor(dataType: DataType, interpolationMethod: InterpolationMethod, startTimestamp?: DOMHighResTimeStamp, endTimestamp?: DOMHighResTimeStamp, quantityKind?: string, measurementUnit?: string, measurementUnitMultiplier?: number, measurementUnitOffset?: number, name?: string, description?: string, expression?: string);
    validate(): boolean;
    clone(): TimeSeriesPath;
    deepClone(): TimeSeriesPath;
    setTimeVector(timestamps: DOMHighResTimeStamp[], values: Values, statuses: number[]): TimeSeriesPath;
    setTimeEntries(timeEntries: TimeEntry[]): TimeSeriesPath;
    getTimeEntries(): TimeEntry[];
    setTimeSegments(timeSegments: TimeSegment[]): TimeSeriesPath;
    getTimeSegments(): TimeSegment[];
    private _resampleNone;
    private _resamplePrevious;
    private _resampleNext;
    private _setResampleValue;
    protected _resampleLinear(targetTimestamps: number[]): TimeSeriesPath;
    mutableResample(targetTimestamps: DOMHighResTimeStamp[]): TimeSeriesPath;
    resample(targetTimestamps: DOMHighResTimeStamp[]): TimeSeriesPath;
    private operator;
    private operatorScalar;
    private operatorTS;
    add(arg: unknown): TimeSeriesPath;
    subtract(arg: unknown): TimeSeriesPath;
    multiply(arg: unknown): TimeSeriesPath;
    divide(arg: unknown): TimeSeriesPath;
    pow(arg: unknown): TimeSeriesPath;
    remainder(arg: unknown): TimeSeriesPath;
    lt(arg: unknown): TimeSeriesPath;
    negate(): TimeSeriesPath;
    private static aggregate;
    static sum(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static avg(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static min(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static max(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
    static range(timeSeriesPeriods: TimeSeriesPath[]): TimeSeriesPath;
}
export {};
